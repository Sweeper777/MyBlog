---
tags: swift generics
op_link: https://stackoverflow.com/q/69268659/5133585
op_profile_link: https://stackoverflow.com/users/247090/drekka
op_name: "drekka"
title: "Type Inference With 'as?'"
---

### Premise

OP has a method like this:

{% highlight swift %}
func get<T>() -> T? {
    // For example purposes I'm hard coding the result.
    return 5 as? T
}
{% endhighlight %}

They find that calling the method in these ways makes the compiler infer the generic type parameter `T` correctly:

{% highlight swift %}
if let x = get() as Int? { /* true */ }
if let x: Int? = get() { /* true */ }
{% endhighlight %}

However, if they instead call it this way:

{% highlight swift %}
if let x = get() as? Int { /* does not compile */ }
{% endhighlight %}

There will be an error saying tnat `T` cannot be inferred. They wonder why this happens.

### Initial Thoughts

First, I checked that `get() as? Int` does typecheck if `T` is `Int`. Well, if `T` is `Int`, the LHS of `as?` would be of type `Int?`, and trying to cast an `Int` to an `Int?` definitely works.

Hold on, doesn't _any_ type work here? The LHS of the `as?` can be _any_ type! That is why the concrete type of `T` is ambiguous. OTOH, in the case of `get() as Int?`, the only thing that `T` can be is `Int`. There's no other possibility that will also make the code compile.

My theory is soon busted though. I thought I situation such as:

{% highlight swift %}
func get<T>() -> T? {
    print(T.self) // checking what T is
    return 5 as? T
}
if let x = get() as Int??? {}
{% endhighlight %}

`T` is inferred as `Int??`, but `T` can also be `Int`, or `Int?`. It seems like the explanation is not as simple as "because there is only one possibility for `T`" in one case, and "because there are multiple possiblilities for `T`" in the other case.

Next, I tried to find evidence for the argument that `as` is _designed_ to be a way to specify the type of an expression, whereas `as?` is _designed_ to be a way to do casting, and so does not care about what type its LHS is. However, after a lot of searching, I was only able to find [this post](https://stackoverflow.com/questions/26057276/downcasting-in-swift-with-as-and-as) that is somewhat related. It says that an `as` expression is "expected to always succeed", which does support my theory that `as` adds some sort of limit to the type of its LHS expression. The [Swift Guide](https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html#ID342) talks about `as` in the context of switch statements, so I don't think quoting it here would be convincing enough.

### The Constraint System

Then I remembered reading from somewhere that the Swift type inference system works on a "constraint system". Constraints are generated by going through the AST, and then resolved. If I can find out what constraints are generated for `get() as? Int` and `get() as Int?`, and show that there are "stronger" constraints for the latter, causing the typechecker to resolve them more easily, that would be a great answer. I tried looking for the document that I read ages ago. I tried googling "swift type inference under the hood", "swift type inference implementation" and finally found it with "swift type inference design". However, it's somehow the Swift 2.2 version, and it's called "[Type Checker Design and Implementation](https://apple-swift.readthedocs.io/en/latest/TypeChecker.html)" Are there no new versions available? Did new Swift versions stop using this system? I wondered.

Anyway, I read through the "constraint generation" part of the document, mainly to see what constraints are generated for the expressions `get() as Int?` and `get() as? Int`. Unfortunately, it doesn't mention anything about `as` in the examples. Apparently `as` is not important enough :(

### Going Through The Compiler's Source Code

I thought, I'll just go into the compiler's source code and have a look. This is my first time doing this, but at least I know where to start from - "constraint generation". In the [Swift repo](https://github.com/apple/swift), I searched for "constraint generation". There are many results, but the second result - a file called "TypeChecker.md" - is exactly the "Type Checker Design and Implementation" document that I was reading! So there is a new version after all. I scrolled through the search results, and eventually found the file "CSGen.cpp", with the comment:

{% highlight cpp %}
// This file implements constraint generation for the type checker.
{% endhighlight %}

Oh great! All the constraint generation is done in one file! I opened the file, and looked for "cast". I found a lot of places where it adds something called a "checked cast" constraint:

{% highlight cpp %}
CS.addConstraint(ConstraintKind::CheckedCast, fromType, toType,
                CS.getConstraintLocator(expr));
{% endhighlight %}

I tried to see in which function are these lines located. I scrolled up a bit, and found that these functions all does this:

- `visitIsExpr`
- `visitConditionalCheckedCastExpr`
- `visitForcedCheckedCastExpr`

Hmm, `IsExpr` is obviously `foo is T`. `ConditionalCheckedCastExpr` is probably `foo as? T`, and `ForcedCheckedCastExpr` is `foo as! T`. What is `foo as T` called then? I looked around, and found `visitCoerceExpr` in between `visitForcedCheckedCastExpr` and `visitConditionalCheckedCastExpr`. Wait, `CoerceExpr` could also be `foo as! T`. "Coerce" has the implication of "by force", doesn't it? Being not sure, I looked up `CoerceExpr`, and found its class declaration:

{% highlight cpp %}
/// Represents an explicit coercion from a value to a specific type.
///
/// Spelled 'a as T' and produces a value of type 'T'.
class CoerceExpr final : public ExplicitCastExpr {
{% endhighlight %}

Okay, that confirms it. `CoerceExpr` is `foo as T`.

Naturally, I looked at what different kinds of constraints it adds in `visitCoerceExpr`. Apparently, it does this really special thing:

{% highlight cpp %}
// Add a conversion constraint for the direct conversion between
// types.
CS.addExplicitConversionConstraint(fromType, toType, RememberChoice,
                                    locator);
{% endhighlight %}

I wanted to know what `addExplicitConversionConstraint` does, but I can't find its implementation anywhere in the repo for some reason. Hopefully just showing that `visitCoerceExpr` adds a totally different constraint is convincing enough to the OP :) I'll just have to believe that it is a "stronger" constraint.